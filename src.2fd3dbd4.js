parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"sC8V":[function(require,module,exports) {

},{}],"jzjQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var n=require("fs");exports.examples=[{key:"protocols-interfaces-traits",title:"Protocols/interfaces/traits",code:{swift:"protocol Stackable {\n  associatedtype T\n  var items: [T] { get }\n  mutating func push(_ item: T)\n  mutating func pop() -> T?\n  func peak() -> T?\n}\n\nstruct Stack<Element>: Stackable {\n  var items: [Element] = []\n\n  mutating func push(_ item: Element) {\n    items.append(item)\n  }\n\n  mutating func pop() -> Element? {\n    return items.popLast()\n  }\n\n  func peak() -> Element? {\n    return items.last\n  }\n}\n\nvar s1 = Stack<Int>()\ns1.push(1)\ns1.push(2)\ns1.pop()\nprint(s1.peak()!)\n",kotlin:"interface Stackable<T> {\n  fun push(item: T)\n  fun pop(): T?\n  fun peak(): T?\n}\n\nclass Stack<T> : Stackable<T> {\n  var items: MutableList<T> = mutableListOf()\n\n  override fun push(item: T) {\n    items.add(item)\n  }\n\n  override fun pop(): T? {\n    return items.removeAt(items.size - 1);\n  }\n\n  override fun peak(): T? {\n    return items.last();\n  }\n}\n\nfun main() {\n  val s1 = Stack<Int>();\n  s1.push(1)\n  s1.push(2)\n  s1.pop()\n  println(s1.peak())\n}\n\n",typescript:"interface Stackable<T> {\n  readonly items: T[];\n  push(item: T): void;\n  pop(): T | null;\n  peak(): T | null;\n}\n\nclass Stack<Element>\n  implements Stackable<Element> {\n  items: Element[] = [];\n\n  push(item: Element) {\n    this.items.push(item);\n  }\n\n  pop() {\n    return this.items.pop() || null;\n  }\n\n  peak() {\n    return this.items.length > 0\n      ? this.items[this.items.length - 1]\n      : null;\n  }\n}\n\nconst s1 = new Stack<number>();\ns1.push(1);\ns1.push(2);\ns1.pop();\nconsole.log(s1.peak());\n",rust:'trait Stackable<T> {\n  fn push(&mut self, item: T) -> ();\n  fn pop(&mut self) -> Option<T>;\n  fn peak(&self) -> Option<&T>;\n}\n\nstruct Stack<T> {\n  items: Vec<T>,\n}\n\nimpl<T> Stackable<T> for Stack<T> {\n  fn push(&mut self, item: T) {\n    self.items.push(item);\n  }\n\n  fn pop(&mut self) -> Option<T> {\n    return self.items.pop();\n  }\n\n  fn peak(&self) -> Option<&T> {\n    return self.items.last();\n  }\n}\n\nimpl<T> Stack<T> {\n  fn new() -> Stack<T> {\n    Stack { items: Vec::new() }\n  }\n}\n\nfn main() {\n  let mut s1 = Stack::new();\n  s1.push(1);\n  s1.push(2);\n  s1.pop();\n  print!("{:?}", s1.peak())\n}\n'}},{key:"higher-order-functions",title:"Higher-order functions",code:{swift:"func map<T, U>(\n  _ arr: [T],\n  _ f: (T) -> U\n) -> [U] {\n    var result: [U] = []\n    for item in arr {\n        result.append(f(item))\n    }\n    return result\n}\n\nlet newArr = map(\n  [1, 2, 3],\n  { (n: Int) in n * 2 }\n)\nprint(newArr)\n",kotlin:"fun <T, U>map(\n  arr: List<T>,\n  f: (item: T) -> U\n): List<U> {\n  var result = mutableListOf<U>()\n  for (item: T in arr) {\n    result.add(f(item))\n  }\n  return result\n}\n\nfun main() {\n  var newList = map(\n    listOf(1, 2, 3),\n    { n : Int -> n * 2 }\n  )\n  print(newList)\n}\n",typescript:"function map<T, U>(\n  arr: Array<T>,\n  f: (item: T) => U\n): Array<U> {\n  const result = [];\n  for (const item of arr) {\n    result.push(f(item));\n  }\n  return result;\n}\n\nconst newArr = map([1, 2, 3], n => n * 2);\nconsole.log(newArr);\n",rust:'fn map<T, U>(\n  arr: Vec<T>,\n  mapper: impl Fn(&T) -> U,\n) -> Vec<U> {\n  let mut result = Vec::new();\n  for item in arr.iter() {\n    result.push(mapper(item))\n  }\n  return result;\n}\n\nfn main() {\n  let new_vec = map(vec![1, 2, 3], |n| n * 2);\n  print!("{:?}", new_vec);\n}\n'}},{key:"algebraic-data-types",title:"Algebraic data types",code:{swift:"enum Shape {\n    case Square(side: Double)\n    case Circle(radius: Double)\n}\n\nlet shapes = [\n    Shape.Square(side: 2),\n    Shape.Circle(radius: 4)\n]\n\nfunc getArea(_ shape: Shape) -> Double {\n    switch shape {\n    case .Circle(radius: let r):\n        return Double.pi * r * r\n    case .Square(side: let s):\n        return s * s\n    }\n}\n\nlet totalArea = shapes.reduce(0, {\n    (sum: Double, shape: Shape) in\n    sum + getArea(shape)\n})\n\nprint(totalArea)\n",kotlin:"sealed class Shape {\n  data class Square(\n    val side: Double\n  ) : Shape()\n  data class Circle(\n    val radius: Double\n  ) : Shape()\n}\n\nfun getArea(shape: Shape): Double {\n  return when (shape) {\n    is Shape.Square ->\n      shape.side * shape.side\n    is Shape.Circle ->\n      kotlin.math.PI * shape.radius * shape.radius\n  }\n}\n\nfun main() {\n  val shapes = listOf(\n    Shape.Square(2.0),\n    Shape.Circle(4.0)\n  )\n  val totalArea = shapes.fold(0.0) {\n    sum, shape -> sum + getArea(shape)\n  }\n  println(totalArea)\n}\n",typescript:"const enum ShapeKind {\n  Square,\n  Circle\n}\n\ninterface Square {\n  kind: ShapeKind.Square;\n  side: number;\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\ntype Shape = Square | Circle;\n\nfunction Square(side: number): Square {\n  return {\n    kind: ShapeKind.Square,\n    side\n  };\n}\n\nfunction Circle(radius: number): Circle {\n  return {\n    kind: ShapeKind.Circle,\n    radius\n  };\n}\n\nconst shapes: Shape[] = [Square(2), Circle(4)];\n\nfunction getArea(shape: Shape) {\n  switch (shape.kind) {\n    case ShapeKind.Square:\n      return shape.side * shape.side;\n    case ShapeKind.Circle:\n      return Math.PI * shape.radius ** 2;\n  }\n}\n\nconst totalArea = shapes.reduce(\n  (sum, shape) => sum + getArea(shape),\n  0\n);\n\nconsole.log(totalArea);\n",rust:'use std::f64::consts::PI;\n\nenum Shape {\n  Square { side: f64 },\n  Circle { radius: f64 },\n}\n\nfn get_area(shape: &Shape) -> f64 {\n  return match shape {\n    Shape::Square { side } => side * side,\n    Shape::Circle { radius } => {\n      PI * radius * radius\n    }\n  };\n}\n\nfn main() {\n  let shapes: Vec<Shape> = vec![\n    Shape::Square { side: 2.0 },\n    Shape::Circle { radius: 4.0 },\n  ];\n\n  let total_area =\n    shapes.iter().fold(0f64, |sum, shape| {\n      sum + get_area(&shape)\n    });\n\n  print!("{:?}", total_area)\n}\n'}}];
},{"fs":"sC8V"}],"gKDo":[function(require,module,exports) {
var define;
var o,r=function(){var o=String.fromCharCode,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",e={};function t(o,r){if(!e[o]){e[o]={};for(var n=0;n<o.length;n++)e[o][o.charAt(n)]=n}return e[o][r]}var s={compressToBase64:function(o){if(null==o)return"";var n=s._compress(o,6,function(o){return r.charAt(o)});switch(n.length%4){default:case 0:return n;case 1:return n+"===";case 2:return n+"==";case 3:return n+"="}},decompressFromBase64:function(o){return null==o?"":""==o?null:s._decompress(o.length,32,function(n){return t(r,o.charAt(n))})},compressToUTF16:function(r){return null==r?"":s._compress(r,15,function(r){return o(r+32)})+" "},decompressFromUTF16:function(o){return null==o?"":""==o?null:s._decompress(o.length,16384,function(r){return o.charCodeAt(r)-32})},compressToUint8Array:function(o){for(var r=s.compress(o),n=new Uint8Array(2*r.length),e=0,t=r.length;e<t;e++){var i=r.charCodeAt(e);n[2*e]=i>>>8,n[2*e+1]=i%256}return n},decompressFromUint8Array:function(r){if(null==r)return s.decompress(r);for(var n=new Array(r.length/2),e=0,t=n.length;e<t;e++)n[e]=256*r[2*e]+r[2*e+1];var i=[];return n.forEach(function(r){i.push(o(r))}),s.decompress(i.join(""))},compressToEncodedURIComponent:function(o){return null==o?"":s._compress(o,6,function(o){return n.charAt(o)})},decompressFromEncodedURIComponent:function(o){return null==o?"":""==o?null:(o=o.replace(/ /g,"+"),s._decompress(o.length,32,function(r){return t(n,o.charAt(r))}))},compress:function(r){return s._compress(r,16,function(r){return o(r)})},_compress:function(o,r,n){if(null==o)return"";var e,t,s,i={},p={},u="",c="",a="",l=2,f=3,h=2,d=[],m=0,v=0;for(s=0;s<o.length;s+=1)if(u=o.charAt(s),Object.prototype.hasOwnProperty.call(i,u)||(i[u]=f++,p[u]=!0),c=a+u,Object.prototype.hasOwnProperty.call(i,c))a=c;else{if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;e<h;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;e<8;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;e<h;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;e<16;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}0==--l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=i[a],e=0;e<h;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;0==--l&&(l=Math.pow(2,h),h++),i[c]=f++,a=String(u)}if(""!==a){if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;e<h;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;e<8;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;e<h;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;e<16;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}0==--l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=i[a],e=0;e<h;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;0==--l&&(l=Math.pow(2,h),h++)}for(t=2,e=0;e<h;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;for(;;){if(m<<=1,v==r-1){d.push(n(m));break}v++}return d.join("")},decompress:function(o){return null==o?"":""==o?null:s._decompress(o.length,32768,function(r){return o.charCodeAt(r)})},_decompress:function(r,n,e){var t,s,i,p,u,c,a,l=[],f=4,h=4,d=3,m="",v=[],w={val:e(0),position:n,index:1};for(t=0;t<3;t+=1)l[t]=t;for(i=0,u=Math.pow(2,2),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;switch(i){case 0:for(i=0,u=Math.pow(2,8),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;a=o(i);break;case 1:for(i=0,u=Math.pow(2,16),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;a=o(i);break;case 2:return""}for(l[3]=a,s=a,v.push(a);;){if(w.index>r)return"";for(i=0,u=Math.pow(2,d),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;switch(a=i){case 0:for(i=0,u=Math.pow(2,8),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;l[h++]=o(i),a=h-1,f--;break;case 1:for(i=0,u=Math.pow(2,16),c=1;c!=u;)p=w.val&w.position,w.position>>=1,0==w.position&&(w.position=n,w.val=e(w.index++)),i|=(p>0?1:0)*c,c<<=1;l[h++]=o(i),a=h-1,f--;break;case 2:return v.join("")}if(0==f&&(f=Math.pow(2,d),d++),l[a])m=l[a];else{if(a!==h)return null;m=s+s.charAt(0)}v.push(m),l[h++]=s+m.charAt(0),s=m,0==--f&&(f=Math.pow(2,d),d++)}}};return s}();"function"==typeof o&&o.amd?o(function(){return r}):"undefined"!=typeof module&&null!=module&&(module.exports=r);
},{}],"3T6a":[function(require,module,exports) {
"use strict";var t=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var e in t)Object.hasOwnProperty.call(t,e)&&(n[e]=t[e]);return n.default=t,n};Object.defineProperty(exports,"__esModule",{value:!0});var n=t(require("lz-string"));exports.playground={kotlin:function(t){return"https://play.kotlinlang.org/#".concat(btoa(JSON.stringify({code:t})))},swift:function(t){return"http://online.swiftplayground.run/?sourceURL=data:text/plain,".concat(encodeURIComponent(t))},typescript:function(t){return"https://typescript-play.js.org/#code/".concat(n.compressToEncodedURIComponent(t))},rust:function(t){return"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=".concat(encodeURIComponent(t))}};
},{"lz-string":"gKDo"}],"9B6d":[function(require,module,exports) {
"use strict";function e(e,o){return t(e)||n(e,o)||r()}function r(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function n(e,r){var n=[],t=!0,o=!1,a=void 0;try{for(var u,i=e[Symbol.iterator]();!(t=(u=i.next()).done)&&(n.push(u.value),!r||n.length!==r);t=!0);}catch(c){o=!0,a=c}finally{try{t||null==i.return||i.return()}finally{if(o)throw a}}return n}function t(e){if(Array.isArray(e))return e}Object.defineProperty(exports,"__esModule",{value:!0});var o=require("./examples"),a=require("./playground"),u=document.querySelector("#examples");function i(e){var r=o.examples.find(function(r){return r.key===e});if(!r)throw new Error('Example "'.concat(e,'" not found.'));return r}function c(r){for(var n=0,t=Object.entries(r.code);n<t.length;n++){var o=e(t[n],2),i=o[0],c=o[1],l=document.querySelector("#".concat(i));l.querySelector(".code").textContent=c;var f=l.querySelector(".playground-link");f&&(f.href=a.playground[i](c))}u.value=r.key,location.hash=r.key}if(u.innerHTML=o.examples.map(function(e){return'<option value="'.concat(e.key,'">').concat(e.title,"</option>")}).join("\n"),u.addEventListener("change",function(e){c(i(e.target.value))}),location.hash){var l=location.hash.slice(1);c(i(l))}else c(o.examples[0]);
},{"./examples":"jzjQ","./playground":"3T6a"}]},{},["9B6d"], null)
//# sourceMappingURL=https://agentcooper.github.io/swift-typescript-rust/src.2fd3dbd4.js.map